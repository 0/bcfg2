#!/usr/bin/env python

'''Bcfg2 Client'''
__revision__ = '$Revision$'

from lxml.etree import Element, XML, tostring, XMLSyntaxError

import logging, os, signal, sys, tempfile, time, traceback, xmlrpclib
import Bcfg2.Options

try:
    import Bcfg2.Client.Proxy, Bcfg2.Logging
except KeyError:
    print "Could not read options from configuration file"
    raise SystemExit, 1

def cb_sigint_handler(signum, frame):
    '''Exit upon CTRL-C'''
    os._exit(1)

class Client:
    ''' The main bcfg2 client class '''
    def __init__(self):
        level = 30
        if '-v' in sys.argv:
            level = 20
        if '-d' in sys.argv:
            level = 0
        Bcfg2.Logging.setup_logging('bcfg2', to_syslog=False, level=level)
        self.logger = logging.getLogger('bcfg2')
        self.toolset = None
        self.config = None

        optinfo = {
            # 'optname': (('-a', argdesc, optdesc),
            #                  env, cfpath, default, boolean)),
            'verbose':(('-v', False,"enable verbose output"),
                       False, False, False, True),
            'quick':(('-q', False, "disable some checksum verification"),
                     False, False, False, True),
            'debug':(('-d', False, "enable debugging output"),
                     False, False, False, True),
            'dryrun':(('-n', False, "do not actually change the system"),
                      False, False, False, True),
            'build': (('-B', False, "run in build mode"),
                      False, False, False, True),
            'paranoid':(('-P', False, "make automatic backups of config files"),
                        False, False, False, True),
            'bundle':(('-b', '<bundle>', "only configure the given bundle"),
                      False, False, False, False),
            'file': (('-f', "<configspec>", "configure from a file rather than querying the server"),
                     False, False, False, False),
            'cache': (('-c', "<configspec>", "store the configuration in a file"),
                      False, False, False, False),
            'profile': (('-p', '<profile>', "assert the given profile for the host"),
                        False, False, False, False),
            'remove': (('-r', '(packages|services|all)', "force removal of additional configuration items"),
                       False, False, False, False),
            'help': (('-h', False, "print this help message"),
                     False, False, False, False),
            'setup': (('-C', '<configfile>', "use given config file (default /etc/bcfg2.conf)"),
                      False, False, '/etc/bcfg2.conf', False),
            'server': (('-S', '<server url>', 'the server hostname to connect to'),
                       False, ('components', 'bcfg2'), 'https://localhost:6789', False),
            'user': (('-u', '<user>', 'the user to provide for authentication'),
                     False, ('communication', 'user'), 'root', False),
            'password': (('-x', '<password>', 'the password to provide for authentication'),
                         False, ('communication', 'password'), 'password', False),
            'retries': (('-R', '<numretries>', 'the number of times to retry network communication'),
                        False, ('communication', 'retries'), '3', False),
            }

        self.setup = Bcfg2.Options.OptionParser('bcfg2', optinfo).parse()
        self.logger.debug(self.setup)
        if self.setup['remove'] not in [False, 'all', 'services', 'packages']:
            self.logger.error("Got unknown argument %s for -r" % (self.setup['remove']))
        if (self.setup["file"] != False) and (self.setup["cache"] != False):
            print "cannot use -f and -c together"
            raise SystemExit, 1
        if self.setup['remove'] and self.setup['dryrun']:
            print "cannot use -n and -r together"
            raise SystemExit, 1

    def load_toolset(self, toolset_name):
        '''Import client toolset modules'''
        
        toolset_packages = {
            'debian': "Bcfg2.Client.Debian",
            'rh': "Bcfg2.Client.Redhat",
            'solaris': "Bcfg2.Client.Solaris"
            }

        if toolset_packages.has_key(toolset_name):
            toolset_class = toolset_packages[toolset_name]
        else:
            toolset_class = toolset_name

        try:
            mod = __import__(toolset_class, globals(), locals(), ['*'])
        except:
            self.fatal_error("got unsupported toolset %s from server."
                             % (toolset_name))
                
        try:
            self.toolset = mod.ToolsetImpl(self.config, self.setup)
            
            self.logger.debug("Selected %s toolset..." % (toolset_name))
        except:
            self.critical_error("instantiating toolset %s" %
                                (toolset_name))        

    def run_probe(self, probe):
        '''Execute probe'''
        probe_name = probe.attrib['name']
        ret = Element("probe-data", probe_name, source=probe.attrib['source'])
        try:
            script = open(tempfile.mktemp(), 'w+')
            try:
                script.write("#!%s\n" %
                             (probe.attrib.get('interpreter', '/bin/sh')))
                script.write(probe.text)
                script.close()
                os.chmod(script.name, 0755)             
                ret.text = os.popen(script.name).read()                
            finally:
                os.unlink(script.name)
        except:
            self.critical_error("executing probe %s" % (probe_name))
        return ret

    def critical_error(self, operation):
        '''Print tracebacks in unexpected cases'''
        print "Traceback information (please include in any bug report):"
        (ttype, value, trace) = sys.exc_info()
        for line in traceback.extract_tb(trace):        
            print "File %s, line %i, in %s\n   %s\n" % (line)
            print "%s: %s\n" % (ttype, value)

        self.fatal_error("An unexpected failure occurred in %s" % (operation) )

    def fatal_error(self, message):
        '''Signal a fatal error'''
        print "Fatal error: %s" % (message)
        raise SystemExit, 1

    def run(self):
        ''' Perform client execution phase '''
        times = {}

        # begin configuration
        times['start'] = time.time()

        if self.setup['file']:
            # read config from file
            try:
                self.logger.debug("reading cached configuration from %s" %
                                  (self.setup['file']))
                configfile = open(self.setup['file'], 'r')
                rawconfig = configfile.read()
                configfile.close()
            except IOError:
                self.fatal_error("failed to read cached configuration from: %s"
                                 % (self.setup['file']))
        else:
            # retrieve config from server
            proxy = Bcfg2.Client.Proxy.bcfg2()

            if self.setup['profile']:
                proxy.AssertProfile(self.setup['profile'])

            try:
                probe_data = proxy.GetProbes()
            except xmlrpclib.Fault:
                self.logger.error("Failed to download probes from bcfg2")
                raise SystemExit, 1

            times['probe_download'] = time.time()
        
            try:
                probes = XML(probe_data)
            except XMLSyntaxError, syntax_error:
                self.fatal_error(
                    "server returned invalid probe requests: %s" %
                    (syntax_error))
            
            # execute probes
            try:
                probe_info = [self.run_probe(probe)
                              for probe in probes.findall(".//probe")]
            except:
                self.critical_error("executing probes")

            # upload probe responses
            proxy.RecvProbeData(probe_info)
        
            times['probe_upload'] = time.time()

            try:
                rawconfig = proxy.GetConfig()
            except xmlrpclib.Fault:
                self.logger.error("Failed to download configuration from bcfg2")
                raise SystemExit, 2

            times['config_download'] = time.time()

        if self.setup['cache']:
            try:
                open(self.setup['cache'], 'w').write(rawconfig)
                os.chmod(self.setup['cache'], 33152)
            except IOError:
                self.logger.warning("failed to write config cache file %s" %
                                    (self.setup['cache']))
            times['caching'] = time.time()
            
        try:
            self.config = XML(rawconfig)
        except XMLSyntaxError, syntax_error:
            self.fatal_error("the configuration could not be parsed: %s" %
                             (syntax_error))

        times['config_parse'] = time.time()
    
        if self.config.tag == 'error':
            self.fatal_error("server error: %s" % (self.config.text))

        # Get toolset from server
        try:
            toolset_name = self.config.get('toolset')
        except:
            self.fatal_error("server did not specify a toolset")

        if self.setup['bundle']:
            replacement_xml = Element("Configuration", version='2.0')
            for child in self.config.getchildren():
                if ((child.tag == 'Bundle') and
                    (child.attrib['name'] == self.setup['bundle'])):
                    replacement_xml.append(child)
            self.config = replacement_xml

        # Create toolset handle
        self.load_toolset(toolset_name)

        times['initialization'] = time.time()
        
        # verify state
        self.toolset.Inventory()

        times['inventory'] = time.time()
    
        # summarize current state
        self.toolset.CondDisplayState('initial')

        # install incorrect aspects of configuration
        self.toolset.Install()

        self.toolset.CondDisplayState('final')

        times['install'] = time.time()
        times['finished'] = time.time()

        if not self.setup['file'] and not self.setup['bundle']:
            # upload statistics
            feedback = Element("upload-statistics")
            timeinfo = Element("OpStamps")
            for (event, timestamp) in times.iteritems():
                timeinfo.set(event, str(timestamp))
            stats = self.toolset.GenerateStats(__revision__)
            stats.append(timeinfo)
            feedback.append(stats)

            try:
                proxy.RecvStats(tostring(feedback))
            except xmlrpclib.Fault:
                self.logger.error("Failed to upload configuration statistics")
                raise SystemExit, 2

if __name__ == '__main__':
    signal.signal(signal.SIGINT, cb_sigint_handler)
    Client().run()
