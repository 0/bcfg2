#!/usr/bin/env python

'''Bcfg2 Client'''
__revision__ = '$Revision$'

import logging
import os
import signal
import socket
import sys
import tempfile
import time
import xmlrpclib
import fcntl
import Bcfg2.Options
import Bcfg2.Client.XML
import Bcfg2.Client.Frame
import Bcfg2.Client.Tools
import Bcfg2.Daemon
from Bcfg2.Component import SimpleXMLRPCServer, ComponentInitError, ComponentKeyError, CobaltXMLRPCRequestHandler, TLSServer
from Bcfg2.tlslite.errors import TLSNoAuthenticationError, TLSFingerprintError

import Bcfg2.Proxy
import Bcfg2.Logger

logger = logging.getLogger('bcfg2')

def cb_sigint_handler(signum, frame):
    '''Exit upon CTRL-C'''
    os._exit(1)

DECISION_LIST = Bcfg2.Options.Option('Decision List', default=False,
                                     cmd="--decision-list", odesc='<file>',
                                     long_arg=True)
LOCKFILE = "/var/lock/bcfg2.run"

class FPProxyCall(object):
    def __init__(self, proxy, method):
        self.proxy = proxy
        self.method_name = method
        self.method = getattr(self.proxy.proxy, method)

    def __call__(self, *args):
        try:
            return self.method(*args)
        except Bcfg2.tlslite.errors.TLSFingerprintError:
            self.proxy.proxy = self.proxy.get_proxy()
            self.method = getattr(self.proxy.proxy, self.method_name)
            return self.__call__(*args)

class FPProxy(object):
    def __init__(self, url, user, password, fingerprints):
        self.url = url
        self.user = user
        self.password = password
        self.fingerprints = fingerprints
        self.no_fingerprint = len(fingerprints) == 0
        self.proxy = self.get_proxy()

    def __getattr__(self, field):
        if field not in self.__dict__:
            self.__dict__[field] = FPProxyCall(self, field)
        return self.__dict__[field]

    def get_proxy(self):
        if self.fingerprints:
            fprint = self.fingerprints.pop()
        elif self.no_fingerprint:
            msg = 'no server x509 fingerprint; no server verification performed!'
            print >> sys.stderr, msg
            fprint = None
        else:
            print >> sys.stderr, "Ran out of fingerprints to try"
            raise SystemExit(1)

        try:
            proxy = Bcfg2.Proxy.ComponentProxy(self.url, self.user,
                                               self.password, fprint)
            return proxy
        except:
            logger.error("Unexpected proxy error", exc_info=1)
            raise SystemExit(1)

class Client:
    ''' The main bcfg2 client class '''

    def __init__(self):
        self.toolset = None
        self.config = None

        optinfo = {
            # 'optname': (('-a', argdesc, optdesc),
            #                  env, cfpath, default, boolean)),
            'verbose': Bcfg2.Options.VERBOSE,
            'extra': Bcfg2.Options.CLIENT_EXTRA_DISPLAY,
            'quick': Bcfg2.Options.CLIENT_QUICK,
            'debug': Bcfg2.Options.DEBUG,
            'drivers': Bcfg2.Options.CLIENT_DRIVERS,
            'fingerprint': Bcfg2.Options.SERVER_FINGERPRINT,
            'dryrun': Bcfg2.Options.CLIENT_DRYRUN,
            'build': Bcfg2.Options.CLIENT_BUILD,
            'paranoid': Bcfg2.Options.CLIENT_PARANOID,
            'bundle': Bcfg2.Options.CLIENT_BUNDLE,
            'file': Bcfg2.Options.CLIENT_FILE,
            'interactive': Bcfg2.Options.INTERACTIVE,
            'cache': Bcfg2.Options.CLIENT_CACHE,
            'profile': Bcfg2.Options.CLIENT_PROFILE,
            'remove': Bcfg2.Options.CLIENT_REMOVE,
            'help': Bcfg2.Options.HELP,
            'setup': Bcfg2.Options.CFILE,
            'server': Bcfg2.Options.SERVER_LOCATION, 
            'user': Bcfg2.Options.CLIENT_USER,
            'password': Bcfg2.Options.SERVER_PASSWORD,
            'retries': Bcfg2.Options.CLIENT_RETRIES,
            'kevlar': Bcfg2.Options.CLIENT_KEVLAR,
            'agent': Bcfg2.Options.CLIENT_AGENT,
            'agent-port': Bcfg2.Options.CLIENT_PORT,
            'agent-background': Bcfg2.Options.CLIENT_BACKGROUND,
            'key': Bcfg2.Options.SERVER_KEY,
            'decision-list': DECISION_LIST,
            'encoding': Bcfg2.Options.ENCODING,
            'omit-lock-check': Bcfg2.Options.OMIT_LOCK_CHECK,
            'filelog': Bcfg2.Options.LOGGING_FILE_PATH,
            'decision': Bcfg2.Options.CLIENT_DLIST,
            }

        self.setup = Bcfg2.Options.OptionParser(optinfo)
        self.setup.parse(sys.argv[1:])

        if self.setup['args']:
            print "Bcfg2 takes no arguments, only options"
            print self.setup.buildHelpMessage()
            raise SystemExit(1)
        level = 30
        if self.setup['verbose']:
            level = 20
        if self.setup['debug']:
            level = 0
        Bcfg2.Logger.setup_logging('bcfg2', to_syslog=False, level=level, to_file=self.setup['filelog'])
        self.logger = logging.getLogger('bcfg2')
        self.logger.debug(self.setup)
        if 'drivers' in self.setup and self.setup['drivers'] == 'help':
            self.logger.info("The following drivers are available:")
            self.logger.info(Bcfg2.Client.Tools.drivers)
            raise SystemExit(0)
        if self.setup['remove'] and 'services' in self.setup['remove']:
            self.logger.error("Service removal is nonsensical, disable services to get former behavior")
        if self.setup['remove'] not in [False, 'all', 'services', 'packages']:
            self.logger.error("Got unknown argument %s for -r" % (self.setup['remove']))
        if (self.setup["file"] != False) and (self.setup["cache"] != False):
            print "cannot use -f and -c together"
            raise SystemExit(1)
        if (self.setup["agent"] != False) and (self.setup["interactive"] != False):
            print "cannot use -A and -I together"
            raise SystemExit(1)
        if (self.setup["agent"] and not self.setup["fingerprint"]):
            print "Agent mode requires specification of x509 fingerprint"
            raise SystemExit(1)
        if (self.setup["agent"] and not self.setup["key"]):
            print "Agent mode requires specification of ssl cert + key file"
            raise SystemExit(1)

    def run_probe(self, probe):
        '''Execute probe'''
        name = probe.get('name')
        self.logger.info("Running probe %s" % name)
        ret = Bcfg2.Client.XML.Element("probe-data", name=name, source=probe.get('source'))
        try:
            script = open(tempfile.mktemp(), 'w+')
            try:
                script.write("#!%s\n" %
                             (probe.attrib.get('interpreter', '/bin/sh')))
                script.write(probe.text)
                script.close()
                os.chmod(script.name, 0755)
                ret.text = os.popen(script.name).read().strip()
                self.logger.info("Probe %s has result:\n%s" % (name, ret.text))
            finally:
                os.unlink(script.name)
        except:
            self.logger.error("Failed to execute probe: %s" % (name), exc_info=1)
            raise SystemExit(1)
        return ret

    def fatal_error(self, message):
        '''Signal a fatal error'''
        self.logger.error("Fatal error: %s" % (message))
        if not self.setup["agent"]:
            raise SystemExit(1)
        else:
            self.logger.error("Continuing...")
        
    def run(self):
        ''' Perform client execution phase '''
        times = {}

        # begin configuration
        times['start'] = time.time()

        if self.setup['file']:
            # read config from file
            try:
                self.logger.debug("reading cached configuration from %s" %
                                  (self.setup['file']))
                configfile = open(self.setup['file'], 'r')
                rawconfig = configfile.read()
                configfile.close()
            except IOError:
                self.fatal_error("failed to read cached configuration from: %s"
                                 % (self.setup['file']))
                return(1)
        else:
            # retrieve config from server
            proxy = FPProxy(self.setup['server'], self.setup['user'],
                            self.setup['password'], self.setup['fingerprint'])

            if self.setup['profile']:
                try:
                    proxy.AssertProfile(self.setup['profile'])
                except xmlrpclib.Fault:
                    self.fatal_error("Failed to set client profile")
                    return(1)

            try:
                probe_data = proxy.GetProbes()
            except xmlrpclib.Fault, flt:
                self.logger.error("Failed to download probes from bcfg2")
                self.logger.error(flt.faultString)
                raise SystemExit(1)

            times['probe_download'] = time.time()

            try:
                probes = Bcfg2.Client.XML.XML(probe_data)
            except Bcfg2.Client.XML.ParseError, syntax_error:
                self.fatal_error(
                    "server returned invalid probe requests: %s" %
                    (syntax_error))
                return(1)

            # execute probes
            try:
                probedata = Bcfg2.Client.XML.Element("ProbeData")
                [probedata.append(self.run_probe(probe))
                 for probe in probes.findall(".//probe")]
            except:
                self.logger.error("Failed to Execute probes")
                raise SystemExit(1)

            if len(probes.findall(".//probe")) > 0:
                try:
                    # upload probe responses
                    proxy.RecvProbeData(Bcfg2.Client.XML.tostring(probedata, encoding='UTF-8', xml_declaration=True))
                except:
                    self.logger.error("Failed to upload probe data", exc_info=1)
                    raise SystemExit(1)

            times['probe_upload'] = time.time()

            if self.setup['decision'] in ['whitelist', 'blacklist']:
                try:
                    self.setup['decision_list'] = proxy.GetDecisionList( \
                        self.setup['decision'])
                    self.logger.info("Got Decision List from server:")
                    self.logger.info(self.setup['decision_list'])
                except xmlrpclib.Fault, f:
                    if f.faultCode == 1:
                        print "GetDecisionList method not supported by server"
                    else:
                        self.logger.error("Failed to de", exc_info=1)
                    raise SystemExit(1)

            try:
                rawconfig = proxy.GetConfig()
            except xmlrpclib.Fault:
                self.logger.error("Failed to download configuration from bcfg2")
                raise SystemExit(2)

            times['config_download'] = time.time()

        if self.setup['cache']:
            try:
                open(self.setup['cache'], 'w').write(rawconfig)
                os.chmod(self.setup['cache'], 33152)
            except IOError:
                self.logger.warning("failed to write config cache file %s" %
                                    (self.setup['cache']))
            times['caching'] = time.time()

        try:
            self.config = Bcfg2.Client.XML.XML(rawconfig)
        except Bcfg2.Client.XML.ParseError, syntax_error:
            self.fatal_error("the configuration could not be parsed: %s" %
                             (syntax_error))
            return(1)            

        times['config_parse'] = time.time()

        if self.config.tag == 'error':
            self.fatal_error("server error: %s" % (self.config.text))
            return(1)

        self.tools = Bcfg2.Client.Frame.Frame(self.config,
                                              self.setup,
                                              times, self.setup['drivers'],
                                              self.setup['dryrun'])

        if not self.setup['omit-lock-check']:
            #check lock here
            try:
                lockfile = open(LOCKFILE, 'w')
                try:
                    fcntl.lockf(lockfile.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
                except IOError:
                    #otherwise exit and give a warning to the user
                    self.fatal_error("An other instance of bcfg2 is running. If you what to bypass the check, run with %s option" %
                                     (Bcfg2.Options.OMIT_LOCK_CHECK.cmd))
            except:
                lockfile = None
                self.logger.error("Failed to open lockfile")
        # execute the said configuration
        self.tools.Execute()

        if not self.setup['omit-lock-check']:
            #unlock here
            if lockfile:
                fcntl.lockf(lockfile.fileno(), fcntl.LOCK_UN)
                os.remove(LOCKFILE)
        
        if not self.setup['file']:
            # upload statistics
            feedback = self.tools.GenerateStats()

            try:
                proxy.RecvStats(Bcfg2.Client.XML.tostring(feedback, encoding='UTF-8', xml_declaration=True))
            except xmlrpclib.Fault:
                self.logger.error("Failed to upload configuration statistics")
                raise SystemExit(2)

class FingerCheck(object):
    def __init__(self, fprints):
        self.fingerprints = fprints
        self.logger = logging.getLogger('checker')

    def __call__(self, connection):
        if connection._client:
            chain = connection.session.serverCertChain
        else:
            chain = connection.session.clientCertChain

        if chain == None:
            self.logger.error("Fingerprint authentication error")
            raise TLSNoAuthenticationError()
        if chain.getFingerprint() not in self.fingerprints:
            self.logger.error("Got connection with bad fingerprint %s" \
                              % (chain.getFingerprint()))
            raise TLSFingerprintError(\
                    "X.509 fingerprint mismatch: %s, %s" % \
                    (chain.getFingerprint(), self.fingerprints))

class Agent(Bcfg2.Component.Component):
    """The Bcfg2 Agent component providing XML-RPC access to 'run'"""
    __name__ = 'bcfg2-agent'
    __implementation__ = 'bcfg2-agent'
            
    def __init__(self, client):
        # need to get addr
        self.setup = client.setup
        self.shut = False
        signal.signal(signal.SIGINT, self.start_shutdown)
        signal.signal(signal.SIGTERM, self.start_shutdown)
        self.logger = logging.getLogger('Agent')

        self.static = True
                
        if self.setup["agent-port"]:
            port = int(self.setup["agent-port"])
        elif self.setup["server"]:
            port = int(self.setup["server"].split(':')[1])
        else:
            print "port or server URL not specified"
            raise SystemExit, 1

        location = (socket.gethostname(), port)

        keyfile = self.setup["key"]
        self.password = self.setup["password"]
            
        try:
            TLSServer.__init__(self,
                               location,
                               keyfile,
                               CobaltXMLRPCRequestHandler,
                               FingerCheck(self.setup["fingerprint"]),
                               reqCert=True)
        except socket.error:
            self.logger.error("Failed to bind to socket")
            raise ComponentInitError
        except ComponentKeyError:
            self.logger.error("Failed to parse key" % (keyfile))
            raise ComponentInitError
        except:
            self.logger.error("Failed to load ssl key %s" % (keyfile), exc_info=1)
            raise ComponentInitError
        try:
            SimpleXMLRPCServer.SimpleXMLRPCDispatcher.__init__(self)
        except TypeError:
            SimpleXMLRPCServer.SimpleXMLRPCDispatcher.__init__(self, False, None)
        self.logRequests = 0
        self.port = self.socket.getsockname()[1]
        self.url = "https://%s:%s" % (socket.gethostname(), self.port)
        self.logger.info("Bound to port %s" % self.port)
        self.funcs.update({'system.listMethods':self.addr_system_listMethods})
        self.atime = 0
        self.client = client
        self.funcs.update({
            "run": self.run,
            })

    def run(self, address):
        try:
            os.waitpid(-1, os.WNOHANG)
        except:
            pass
        self.logger.info("Got run request from %s" % (address[0]))
        if os.fork():
            return True
        else:
            try:
                self.client.run()
            except SystemExit:
                self.logger.error("Client failed to execute")
            self.shut = True
            return False
            
if __name__ == '__main__':
    signal.signal(signal.SIGINT, cb_sigint_handler)
    client = Client()
    spid = os.getpid()
    if client.setup["agent"]:
        agent = Agent(client)
        if client.setup["agent-background"]:
            Bcfg2.Daemon.daemonize(client.setup["agent-background"])
        while not agent.shut:
            try:
                agent.serve_forever()
            except:
                agent.logger.error('Error in service loop')
                agent.logger.error('Continuing')
        if os.getpid() == spid:
            print("Shutting down")
    else:
        client.run()
