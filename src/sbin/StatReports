#!/usr/bin/env python
#Jun 7 2005
#StatReports - Joey Hagedorn - hagedorn@mcs.anl.gov

__revision__ = '$Revision$'
'''Generates & distributes reports of statistic information for bcfg2'''

from ConfigParser import ConfigParser
from elementtree.ElementTree import *
from xml.parsers.expat import ExpatError
from xml.sax.saxutils import escape
from time import asctime, strftime, strptime, gmtime, time
from socket import getfqdn
from sys import exit, argv
from getopt import getopt, GetoptError
import re, os, string, libxml2, libxslt
from tempfile import NamedTemporaryFile
from copy import deepcopy

def generatereport(rs, nr):
    '''generatereport creates and returns an ElementTree representation
     of a report adhering to the XML spec for intermediate reports'''
    reportspec = deepcopy(rs)
    nodereprt = deepcopy(nr)

    reportgood = reportspec.get("good", default = 'Y')
    reportmodified = reportspec.get("modified", default = 'Y')

    current_date = asctime()[:10]

    '''build regex of all the nodes we are reporting about'''
    regex = string.join([x.get("name") for x in \
                         reportspec.findall('Machine')], '|')
    pattern = re.compile(regex)


    for node in nodereprt.findall('Node'):

        if node.findall('HostInfo') == [] or \
        not pattern.match(node.get("name")) or \
        node.findall('Statistics') == [] or \
        node.find("HostInfo").get("fqdn") == "":#maybe issue a warning instead?
            nodereprt.remove(node)
            continue

        #reduce to most recent Statistics entry
        statisticslist = node.findall('Statistics')
        #this line actually sorts from most recent to oldest
        statisticslist.sort(lambda y, x: cmp(strptime(x.get("time")), \
                                             strptime(y.get("time"))))
        
        stats = statisticslist[0]

        [node.remove(x) for x in node.findall('Statistics')]
        

        #add a good tag if node is good and we wnat to report such
        if reportgood == 'Y' and stats.get('state') == 'clean':
            SubElement(stats,"Good")

        for x in stats.findall('Modified'):
            if reportmodified == 'N' or x.getchildren() == None:
                stats.remove(x)

        for x in stats.findall('Bad'):
            if x.getchildren() == None:
                stats.remove(x)
                
        #test for staleness -if stale add Stale tag
        if not current_date in stats.get("time"):
            SubElement(stats,"Stale")
            
        node.append(stats)
        
    return nodereprt



def mail(mailbody, delivery, confi):
    '''mail mails a previously generated report'''

    mailer = confi.get('statistics', 'sendmailpath')

    # open a pipe to the mail program and
    # write the data to the pipe
    pipe = os.popen("%s -t" % mailer, 'w')
    pipe.write(mailbody)
    exitcode = pipe.close()
    if exitcode:
        print "Exit code: %s" % exitcode

def rss(reportxml, delivery, report):
    '''rss appends a new report to the specified rss file
     keeping the last 9 articles'''
    #check and see if rss file exists
    for destination in delivery.findall('Destination'):
        try:
            fil = open(destination.attrib['address'], 'r')
            olddoc = XML(fil.read())

            #defines the number of recent articles to keep
            items = olddoc.find("channel").findall("item")[0:9]
            fil.close()
            fil = open(destination.attrib['address'], 'w')
        except (IOError, ExpatError):
            fil = open(destination.attrib['address'], 'w')
            items = []

        rssdata = Element("rss")
        channel = SubElement(rssdata, "channel")
        rssdata.set("version", "2.0")
        chantitle = SubElement(channel, "title")
        chantitle.text = report.attrib['name']
        chanlink = SubElement(channel, "link")
        
        #this can later link to WWW report if one gets published simultaneously?
        chanlink.text = "http://www.mcs.anl.gov/cobalt/bcfg2"
        chandesc = SubElement(channel, "description")
        chandesc.text = "Information regarding the 10 most recent bcfg2 runs."

        channel.append(XML(reportxml))

        if items != []:
            for item in items:
                channel.append(item)

        tree = "<?xml version=\"1.0\"?>" + tostring(rssdata)
        fil.write(tree)
        fil.close()

def www(reportxml, delivery, report):
    '''www outputs report to'''

    #this can later link to WWW report if one gets published simultaneously?    
    for destination in delivery.findall('Destination'):
        fil = open(destination.attrib['address'], 'w')

        fil.write(reportxml)
        fil.close()

def pretty_print(element, level=0):
    '''Produce a pretty-printed text representation of element'''
    if element.text:
        fmt = "%s<%%s %%s>%%s</%%s>" % (level*" ")
        data = (element.tag, (" ".join(["%s='%s'" % keyval for keyval in element.attrib.iteritems()])),
                element.text, element.tag)
    if element._children:
        fmt = "%s<%%s %%s>\n" % (level*" ",) + (len(element._children) * "%s") + "%s</%%s>\n" % (level*" ")
        data = (element.tag, ) + (" ".join(["%s='%s'" % keyval for keyval in element.attrib.iteritems()]),)
        data += tuple([pretty_print(entry, level+2) for entry in element._children]) + (element.tag, )
    else:
        fmt = "%s<%%s %%s/>\n" % (level * " ")
        data = (element.tag, " ".join(["%s='%s'" % keyval for keyval in element.attrib.iteritems()]))
    return fmt % data


if __name__ == '__main__':
    c = ConfigParser()
    c.read(['/etc/bcfg2.conf'])
    configpath = "%s/report-configuration.xml" % c.get('server', 'metadata')
    statpath = "%s/statistics.xml" % c.get('server', 'metadata')
    hostinfopath = "%s/hostinfo.xml" % c.get('server', 'metadata')
    metadatapath = "%s/metadata.xml" % c.get('server', 'metadata')
    transformpath = "/usr/share/bcfg2/xsl-transforms/"
    web-srcspath = "/usr/share/bcfg2/web-rprt-srcs/"

    try:
        opts, args = getopt(argv[1:], "hc:s:", ["help", "config=", "stats="])
    except GetoptError, mesg:
        # print help information and exit:
        print "%s\nUsage:\nStatReports.py [-h] [-c <configuration-file>] [-s <statistics-file>]" % (mesg) 
        exit(2)
    for o, a in opts:
        if o in ("-h", "--help"):
            print "Usage:\nStatReports.py [-h] [-c <configuration-file>] [-s <statistics-file>]"
            exit()
        if o in ("-c", "--config"):
            configpath = a
        if o in ("-s", "--stats"):
            statpath = a


    #See if hostinfo.xml exists, and is less than 23.5 hours old
    try:
        hostinstat = os.stat(hostinfopath)
        if (time() - hostinstat[9])/(60*60) > 23.5:
            os.system('GenerateHostInfo')#Generate HostInfo needs to be in the path
    except OSError:
        os.system('GenerateHostInfo')#Generate HostInfo needs to be in the path


    '''Reads Data & Config files'''
    try:
        statsdata = XML(open(statpath).read())
    except (IOError, ExpatError):
        print("StatReports: Failed to parse %s"%(statpath))
        exit(1)
    try:
        configdata = XML(open(configpath).read())
    except (IOError, ExpatError):
        print("StatReports: Failed to parse %s"%(configpath))
        exit(1)
    try:
        metadata = XML(open(metadatapath).read())
    except (IOError, ExpatError):
        print("StatReports: Failed to parse %s"%(metadatapath))
        exit(1)
    try:
        hostinfodata = XML(open(hostinfopath).read())
    except (IOError, ExpatError):
        print("StatReports: Failed to parse %s. Is GenerateHostInfo in your path?"%(hostinfopath))
        exit(1)


    #Merge data from three sources
    nodereport = Element("Report", attrib={"time" : asctime()})

    #should all of the other info in Metadata be appended?
    #What about all of the package stuff for other types of reports?
    
    for client in metadata.findall("Client"):
        nodel = Element("Node", attrib={"name" : client.get("name")})
        nodel.append(client)
        for hostinfo in hostinfodata.findall("HostInfo"):
            if hostinfo.get("name") == client.get("name"):
                nodel.append(hostinfo)

        for nod in statsdata.findall("Node"):
            if nod.get("name") == client.get("name"):
                for statel in nod.findall("Statistics"):
                    nodel.append(statel)
        nodereport.append(nodel)


    for reprt in configdata.findall('Report'):
        nodereport.set("name", reprt.get("name", default="BCFG Report"))

        procnodereport = generatereport(reprt, nodereport)

        for deliv in reprt.findall('Delivery'):
            #is a deepcopy of procnodereport necessary?
            
            delivtype = deliv.get('type', default='nodes-digest')
            deliverymechanism = deliv.get('mechanism', default='invalid')

            #apply XSLT, different ones based on report type, and options
            transform = ''
            if deliverymechanism == 'mail':
                if delivtype == 'nodes-individual':
                    transform = 'nodes-individual-email.xsl'                    
                elif delivtype == 'overview-stats':
                    transform = 'overview-stats-email.xsl'
                else:
                    transform = 'nodes-digest-email.xsl'
            elif deliverymechanism == 'rss':
                if delivtype == 'overview-stats':
                    transform = 'overview-stats-rss.xsl'
                else:
                    transform = 'nodes-digest-rss.xsl'
            elif deliverymechanism == 'www':
                if delivtype == 'overview-stats':
                    transform = 'overview-stats-html.xsl'
                else:
                    transform = 'nodes-digest-html.xsl'
            else:
                print("StatReports: Invalid delivery mechanism in report-configuration!")
                exit(1)

            #IMPORTANT to add some error checking here-parseerrors
            #this might be sufficient
            try:
                styledoc = libxml2.parseFile(transformpath+transform)
                style = libxslt.parseStylesheetDoc(styledoc)
            except:
                print("StatReports: invalid XSLT transform file.")
                exit(1)
                
            if deliverymechanism == 'mail':
                if delivtype == 'nodes-individual':
                    p2noderep = deepcopy(procnodereport)
                    for noden in procnodereport.findall("Node"):
                        for x in p2noderep.findall("Node"):
                            p2noderep.remove(x)
                        p2noderep.append(noden)
                        tempr = NamedTemporaryFile()
                        tempr.write(tostring(p2noderep))
                        tempr.seek(0)
                        doc = libxml2.parseFile(tempr.name)
                        tempr.close()
                        del tempr
                        result = style.applyStylesheet(doc, None)
                        try:
                            outputstring = style.saveResultToString(result)
                        except:
                            outputstring = None#this is a nasty hack. When the xslt transform breaks-- just blank it out
                            #this is done due to a bug in libxslt
                            #This needs to be fixed in future releases
                        if not outputstring == None:
                            toastring = ''
                            for desti in deliv.findall("Destination"):
                                toastring = "%s%s " % (toastring, desti.get('address'))
                            #prepend To: and From:
                            outputstring = "To: %s\nFrom: root@%s\n%s"% (toastring, getfqdn(), outputstring)
                            mail(outputstring, deliv, c) #call function to send
                        doc.freeDoc()
                        result.freeDoc()
                    style.freeStylesheet()
                else:
                    tempr = NamedTemporaryFile()
                    tempr.write(tostring(procnodereport))
                    tempr.seek(0)
                    doc = libxml2.parseFile(tempr.name)
                    tempr.close()
                    del tempr
                    result = style.applyStylesheet(doc, None)
                    outputstring = style.saveResultToString(result)
                    if not outputstring == None:
                        toastring = ''
                        for desti in deliv.findall("Destination"):
                            toastring = "%s%s " % (toastring, desti.get('address'))
                        #prepend To: and From:
                        outputstring = "To: %s\nFrom: root@%s\n%s"% (toastring, getfqdn(), outputstring)
                        mail(outputstring, deliv, c) #call function to send
                    style.freeStylesheet()
                    doc.freeDoc()
                    result.freeDoc()
            else:
                tempr = NamedTemporaryFile()
                tempr.write(tostring(procnodereport))
                tempr.seek(0)
                doc = libxml2.parseFile(tempr.name)
                tempr.close()
                del tempr
                result = style.applyStylesheet(doc, None)
                outputstring = style.saveResultToString(result)
                if deliverymechanism == 'rss':
                    rss(outputstring, deliv, reprt)
                else: # must be deliverymechanism == 'www':
                    www(outputstring, deliv, reprt)
                style.freeStylesheet()
                doc.freeDoc()
                result.freeDoc()
